/* --------------------------------------------------------------------------------
  This file was automatically generated by the Athlos Project Editor.
  Athlos Project Editor, v1.0 BETA
-------------------------------------------------------------------------------- */

package com.example.marspioneer.state;


import com.example.marspioneer.model.*;
import com.example.marspioneer.proto.*;
import com.example.marspioneer.persistence.DBManager;
import com.example.marspioneer.generation.MPTerrainGenerator;
import com.raylabz.jsec.HashType;
import com.raylabz.jsec.Hashing;
import redis.clients.jedis.Jedis;

import java.util.*;

public class WorldContext {

    private final String worldID;
    private final MPWorld world;
    private final MPTerrainGenerator terrainGenerator;
    private final HashSet<MPWorldSession> subscribedSessions = new HashSet<>();
    private final Jedis jedis;

    public WorldContext(String worldID, Jedis jedis) {
        this.worldID = worldID;
        this.jedis = jedis;
        this.world = DBManager.world.get(worldID);
        this.terrainGenerator = new MPTerrainGenerator(world);
    }

    public String getWorldID() {
        return worldID;
    }

    public MPTerrainGenerator getTerrainGenerator() {
        return terrainGenerator;
    }

    public MPWorld getWorld() {
        return world;
    }

    /**
     * Requests terrain data for a specific chunk.
     * @param chunkRow The row of the chunk to load.
     * @param chunkCol The column of the chunk to load.
     * @return Returns a TerrainChunk.
     */
    private MPTerrainChunk requestChunk(int chunkRow, int chunkCol) {
        final String chunkHash = Hashing.hash(HashType.MD5, chunkRow + "," + chunkCol);

        //Find the chunk using the identifier:
        MPTerrainIdentifier chunkIdentifier = null;
        final Collection<MPTerrainIdentifier> terrainIdentifiers = DBManager.terrainIdentifier.listForWorld(worldID);
        for (MPTerrainIdentifier terrainIdentifier : terrainIdentifiers) {
            if (terrainIdentifier.getChunkPosition().toHash().equals(chunkHash)) {
                chunkIdentifier = terrainIdentifier;
            }
        }

        //Retrieve the chunk by ID, if it exists:
        if (chunkIdentifier != null) {
            return DBManager.terrainChunk.get(chunkIdentifier.getChunkID());
        }
        //If cache and/or database don't have the chunk, generate it and store it:
        else {
            final MPTerrainChunk generatedChunk = terrainGenerator.generateChunk(chunkRow, chunkCol);
            DBManager.terrainChunk.create(generatedChunk);
            MPWorld updatedWorld = DBManager.world.get(worldID);
            updatedWorld.addChunk(generatedChunk.getId());
            DBManager.world.update(updatedWorld);
            return generatedChunk;
        }
    }

    /**
     * Retrieves the terrain cells that are within the area of interest of a list of entities.
     * @param entities The list of entities.
     * @return Returns a Map containing the terrain cells.
     */
    public Map<String, MPTerrainCellProto> getTerrain(Collection<MPEntity> entities) {

        HashMap<String, MPTerrainCellProto> cells = new HashMap<>();

        HashSet<MatrixPosition> chunksNeeded = new HashSet<>();
        for (MPEntity entity : entities) {
            int minRow, maxRow, minCol, maxCol;
            minRow = (int) (entity.getPosition().getRow() - entity.getAreaOfInterest());
            maxRow = (int) (entity.getPosition().getRow() + entity.getAreaOfInterest());
            minCol = (int) (entity.getPosition().getCol() - entity.getAreaOfInterest());
            maxCol = (int) (entity.getPosition().getCol() + entity.getAreaOfInterest());

            final int INCREMENTATION_STEP = (int) Math.min(entity.getAreaOfInterest(), MPTerrainChunk.SIZE);

            for (int cellRow = minRow; cellRow <= maxRow; cellRow += INCREMENTATION_STEP) {
                for (int cellCol = minCol; cellCol <= maxCol; cellCol += INCREMENTATION_STEP) {
                    chunksNeeded.add(MPTerrainChunk.getChunkPosition(cellRow, cellCol));
                }
            }
        }

        ArrayList<MPTerrainChunk> chunks = new ArrayList<>();
        for (MatrixPosition chunkPos : chunksNeeded) {
            if (world.chunkIsInBounds(chunkPos.getRow(), chunkPos.getCol())) {
                //Request the entire chunk:
                long t = System.currentTimeMillis();
                MPTerrainChunk chunk = requestChunk(chunkPos.getRow(), chunkPos.getCol());
                System.out.println("requestChunk(" + chunkPos.getRow() + "," + chunkPos.getCol() + ") -> " + (System.currentTimeMillis() - t));
                chunks.add(chunk);
            }
        }

        for (MPEntity entity : entities) {
            for (MPTerrainChunk chunk : chunks) {
                //Only include cells from this chunk that are within the AoI:
                for (Map.Entry<String, MPTerrainCell> entry : chunk.getCells().entrySet()) {
                    final MatrixPosition position = entry.getValue().getPosition();
                    final double distance = position.distanceTo(entity.getPosition());
                    if (distance <= entity.getAreaOfInterest()) {
                        cells.put(position.toHash(), entry.getValue().toProto().build());
                    }
                }
            }
        }
        return cells;
    }

    /**
     * Retrieves the terrain cells that are within the area of interest of a specific position.
     * @param position The position.
     * @param radius The radius of the area of interest.
     * @return Returns a map of terrain cells.
     */
    public Map<String, MPTerrainCellProto> getTerrain(MatrixPosition position, float radius) {
        HashMap<String, MPTerrainCellProto> cells = new HashMap<>();

        HashSet<MatrixPosition> chunksNeeded = new HashSet<>();
        int minRow, maxRow, minCol, maxCol;
        minRow = (int) (position.getRow() - radius);
        maxRow = (int) (position.getRow() + radius);
        minCol = (int) (position.getCol() - radius);
        maxCol = (int) (position.getCol() + radius);

        final int INCREMENTATION_STEP = (int) Math.min(radius, MPTerrainChunk.SIZE);

        for (int cellRow = minRow; cellRow <= maxRow; cellRow += INCREMENTATION_STEP) {
            for (int cellCol = minCol; cellCol <= maxCol; cellCol += INCREMENTATION_STEP) {
                chunksNeeded.add(MPTerrainChunk.getChunkPosition(cellRow, cellCol));
            }
        }

        ArrayList<MPTerrainChunk> chunks = new ArrayList<>();
        for (MatrixPosition chunkPos : chunksNeeded) {
            if (world.chunkIsInBounds(chunkPos.getRow(), chunkPos.getCol())) {
                //Request the entire chunk:
                long t = System.currentTimeMillis();
                MPTerrainChunk chunk = requestChunk(chunkPos.getRow(), chunkPos.getCol());
                System.out.println("requestChunk(" + chunkPos.getRow() + "," + chunkPos.getCol() + ") -> " + (System.currentTimeMillis() - t));
                chunks.add(chunk);
            }
        }

        for (MPTerrainChunk chunk : chunks) {
            //Only include cells from this chunk that are within the AoI:
            for (Map.Entry<String, MPTerrainCell> entry : chunk.getCells().entrySet()) {
                final MatrixPosition cellPosition = entry.getValue().getPosition();
                final double distance = cellPosition.distanceTo(position);
                if (distance <= radius) {
                    cells.put(cellPosition.toHash(), entry.getValue().toProto().build());
                }
            }
        }
        return cells;
    }

    /**
     * Retrieves the entities that are within the area of interest of a given set of entities.
     * @param entities The entities given.
     * @return Returns a map of entities.
     */
    public Map<String, MPEntityProto> getEntities(Collection<MPEntity> entities) {
        HashMap<String, MPEntityProto> entitiesInAOI = new HashMap<>();
        for (MPEntity e : entities) {
            entitiesInAOI.put(e.getId(), e.toProto().build());
        }
        final Collection<MPEntity> allEntities = DBManager.entity.listForWorld(worldID);
        allEntities.addAll(DBManager.buildingEntity.listForWorld(worldID));
        for (MPEntity providedEntity : entities) {
            for (MPEntity entity : allEntities) {
                if (!providedEntity.getId().equals(entity.getId()) && !entitiesInAOI.containsKey(entity.getId())) {
                    if (providedEntity.getPosition().distanceTo(entity.getPosition()) <= providedEntity.getAreaOfInterest()) {
                        entitiesInAOI.put(entity.getId(), entity.toProto().build());
                    }
                }
            }
        }
        return entitiesInAOI;
    }

    /**
     * Retrieves the entities that are within a radius of a given position.
     * @param position The position given.
     * @param radius The radius.
     * @return Returns a map of entities.
     */
    public Map<String, MPEntityProto> getEntities(MatrixPosition position, float radius) {
        HashMap<String, MPEntityProto> entitiesInAOI = new HashMap<>();
        final Collection<BuildingEntity> allEntities = DBManager.buildingEntity.listForWorld(worldID);
        for (BuildingEntity entity : allEntities) {
            if (!entitiesInAOI.containsKey(entity.getId())) {
                if (position.distanceTo(entity.getPosition()) <= radius) {
                    entitiesInAOI.put(entity.getId(), entity.toProto().build());
                }
            }
        }
        return entitiesInAOI;
    }

    /**
     * Composes the partial state for a given world session and set of entities.
     * @param worldSession The world session to compose the state for.
     * @return Returns a PartialStateProto.
     */
    public MPPartialStateProto composeState(MPWorldSession worldSession) {
        //Retrieve the player's own entities:
        final Collection<MPEntity> playerEntities = DBManager.entity.listForPlayerAndWorld(worldSession.getWorldID(), worldSession.getPlayerID());
//        playerEntities.addAll(DBManager.buildingEntity.listForPlayerAndWorld(worldSession.getWorldID(), worldSession.getPlayerID()));

        //Retrieve foreign entities that are within the area of interest of the player's entities:
        final HashMap<String, MPEntityProto> entitiesInAOI = new HashMap<>(getEntities(playerEntities));

        //Retrieve the terrain:
        final HashMap<String, MPTerrainCellProto> terrainInAOI = new HashMap<>(getTerrain(playerEntities));
        return MPPartialStateProto.newBuilder()
                .setWorldSession(worldSession.toProto())
                .putAllEntities(entitiesInAOI)
                .putAllCells(terrainInAOI)
                .build();
    }

    /**
     * Composes a state update.
     * @param worldSession The world session to compose the state for.
     * @param actionPosition The action's position.
     * @param areaOfEffect The action's area of effect (AoE).
     * @return Returns a PartialStateProto.
     */
    public MPPartialStateProto composeStateUpdate(MPWorldSession worldSession, MatrixPosition actionPosition, float areaOfEffect) {
        //Retrieve the player's own entities:
        final Collection<MPEntity> playerEntities = DBManager.entity.listForPlayerAndWorld(worldSession.getWorldID(), worldSession.getPlayerID());
        playerEntities.addAll(DBManager.buildingEntity.listForPlayerAndWorld(worldSession.getWorldID(), worldSession.getPlayerID()));

        //Retrieve foreign entities that are within the area of interest of the player's entities:
        final HashMap<String, MPEntityProto> entitiesInAOI = new HashMap<>(getEntities(actionPosition, areaOfEffect));

        //Retrieve the terrain:
        final HashMap<String, MPTerrainCellProto> terrainInAOI = new HashMap<>(getTerrain(actionPosition, areaOfEffect));
        return MPPartialStateProto.newBuilder()
                .setWorldSession(worldSession.toProto())
                .putAllEntities(entitiesInAOI)
                .putAllCells(terrainInAOI)
                .build();
    }

    /**
     * Composes a state update.
     * @param worldSession The world session to compose the state for.
     * @return Returns a PartialStateProto.
     */
    public MPPartialStateProto composeStateUpdate(MPWorldSession worldSession) {
        //Retrieve the player's own entities:
        final Collection<MPEntity> playerEntities = DBManager.entity.listForPlayerAndWorld(worldSession.getWorldID(), worldSession.getPlayerID());
//        playerEntities.addAll(DBManager.buildingEntity.listForPlayerAndWorld(worldSession.getWorldID(), worldSession.getPlayerID()));

        //Retrieve foreign entities that are within the area of interest of the player's entities:
        final HashMap<String, MPEntityProto> entitiesInAOI = new HashMap<>(getEntities(playerEntities));

        //Retrieve the terrain:
        long t = System.currentTimeMillis();
        final HashMap<String, MPTerrainCellProto> terrainInAOI = new HashMap<>(getTerrain(playerEntities));
        System.out.println("getTerrain -> " + (System.currentTimeMillis() - t));

        final MPPartialStateProto build = MPPartialStateProto.newBuilder()
                .setWorldSession(worldSession.toProto())
                .putAllEntities(entitiesInAOI)
                .putAllCells(terrainInAOI)
                .build();

        return build;
    }

    //TODO - Not within the framework!
    /**
     * Composes a state update.
     * @param worldSession The world session to compose the state for.
     * @return Returns a PartialStateProto.
     */
    public MPPartialStateProto composeStateUpdateWithTerrain(MPWorldSession worldSession, HashMap<String, MPTerrainCellProto> existingTerrain) {
        //Retrieve the player's own entities:
        final Collection<MPEntity> playerEntities = DBManager.entity.listForPlayerAndWorld(worldSession.getWorldID(), worldSession.getPlayerID());
        playerEntities.addAll(DBManager.buildingEntity.listForPlayerAndWorld(worldSession.getWorldID(), worldSession.getPlayerID()));

        //Retrieve foreign entities that are within the area of interest of the player's entities:
        final HashMap<String, MPEntityProto> entitiesInAOI = new HashMap<>(getEntities(playerEntities));

        //Retrieve the terrain:
        return MPPartialStateProto.newBuilder()
                .setWorldSession(worldSession.toProto())
                .putAllEntities(entitiesInAOI)
                .putAllCells(existingTerrain)
                .build();
    }

    //TODO - Not within the framework!
    /**
     * Composes a state update.
     * @param worldSession The world session to compose the state for.
     * @return Returns a PartialStateProto.
     */
    public MPPartialStateProto composeStateUpdateWithEntities(MPWorldSession worldSession, HashMap<String, MPEntityProto> existingEntities) {
        //Retrieve the player's own entities:
        final Collection<MPEntity> playerEntities = DBManager.entity.listForPlayerAndWorld(worldSession.getWorldID(), worldSession.getPlayerID());
        playerEntities.addAll(DBManager.buildingEntity.listForPlayerAndWorld(worldSession.getWorldID(), worldSession.getPlayerID()));

        //Retrieve the terrain:
        final HashMap<String, MPTerrainCellProto> terrainInAOI = new HashMap<>(getTerrain(playerEntities));
        return MPPartialStateProto.newBuilder()
                .setWorldSession(worldSession.toProto())
                .putAllEntities(existingEntities)
                .putAllCells(terrainInAOI)
                .build();
    }

    //TODO - Not within the framework!
    /**
     * Composes a state update.
     * @param worldSession The world session to compose the state for.
     * @return Returns a PartialStateProto.
     */
    public MPPartialStateProto composeStateUpdateWithEntitiesAndTerrain(MPWorldSession worldSession, Collection<MPEntityProto> existingEntities, Collection<MPTerrainCellProto> existingTerrain) {
        //Retrieve the player's own entities:
        final Collection<MPEntity> playerEntities = DBManager.entity.listForPlayerAndWorld(worldSession.getWorldID(), worldSession.getPlayerID());
        playerEntities.addAll(DBManager.buildingEntity.listForPlayerAndWorld(worldSession.getWorldID(), worldSession.getPlayerID()));

        HashMap<String, MPEntityProto> entities = new HashMap<>();
        HashMap<String, MPTerrainCellProto> terrain = new HashMap<>();
        for (MPEntityProto existingEntity : existingEntities) {
            entities.put(existingEntity.getId(), existingEntity);
        }
        for (MPTerrainCellProto mpTerrainCellProto : existingTerrain) {
            terrain.put(mpTerrainCellProto.getPosition().toHash(), mpTerrainCellProto);
        }

        return MPPartialStateProto.newBuilder()
                .setWorldSession(worldSession.toProto())
                .putAllEntities(entities)
                .putAllCells(terrain)
                .build();
    }

    /**
     * Returns the active sessions for this world.
     * @return Returns a collection of WorldSessions.
     */
    public Collection<MPWorldSession> getSessions() {
        return DBManager.worldSession.listForWorld(worldID);
    }

    /**
     * Subscribes a world session to a world.
     * @param worldSession The world session.
     */
    public void subscribe(MPWorldSession worldSession) {
        subscribedSessions.add(worldSession);
    }

    /**
     * Unsubscribes a world session.
     * @param worldSession The world session to unsubscribe.
     */
    public void unsubscribe(MPWorldSession worldSession) {
        subscribedSessions.remove(worldSession);
    }

    /**
     * Unsubscribes a world session.
     * @param worldSessionID The world session to unsubscribe.
     */
    public void unsubscribe(String worldSessionID) {
        MPWorldSession removedSession = null;
        for (MPWorldSession worldSession : subscribedSessions) {
            if (worldSession.getId().equals(worldSessionID)) {
                removedSession = worldSession;
                break;
            }
        }
        if (removedSession != null) {
            subscribedSessions.remove(removedSession);
        }
    }
}

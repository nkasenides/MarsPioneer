/* --------------------------------------------------------------------------------
  This file was automatically generated by the Athlos Project Editor.
  Athlos Project Editor, v1.0 BETA
-------------------------------------------------------------------------------- */

package com.example.marspioneer.state;


import com.example.marspioneer.model.*;
import com.example.marspioneer.proto.*;
import com.example.marspioneer.persistence.DBManager;
import com.example.marspioneer.generation.MPTerrainGenerator;
import com.raylabz.jsec.HashType;
import com.raylabz.jsec.Hashing;
import redis.clients.jedis.Jedis;

import java.util.*;

public class WorldContext {

    private final String worldID;
    private final MPWorld world;
    private final MPTerrainGenerator terrainGenerator;

    public WorldContext(String worldID) {
        this.worldID = worldID;
        this.world = DBManager.world.get(worldID);
        this.terrainGenerator = new MPTerrainGenerator(world);
    }

    public String getWorldID() {
        return worldID;
    }

    public MPTerrainGenerator getTerrainGenerator() {
        return terrainGenerator;
    }

    public MPWorld getWorld() {
        return world;
    }

    /**
     * Requests terrain data for a specific chunk.
     * @param chunkRow The row of the chunk to load.
     * @param chunkCol The column of the chunk to load.
     * @return Returns a TerrainChunk.
     */
    private MPTerrainChunk requestChunk(int chunkRow, int chunkCol) {
        final String chunkHash = Hashing.hash(HashType.MD5, chunkRow + "," + chunkCol);

        //Find the chunk using the identifier:
        MPTerrainIdentifier chunkIdentifier = null;
        final Collection<MPTerrainIdentifier> terrainIdentifiers = DBManager.terrainIdentifier.listForWorld(worldID);
        for (MPTerrainIdentifier terrainIdentifier : terrainIdentifiers) {
            if (terrainIdentifier.getChunkPosition().toHash().equals(chunkHash)) {
                chunkIdentifier = terrainIdentifier;
            }
        }

        //Retrieve the chunk by ID, if it exists:
        if (chunkIdentifier != null) {
            return DBManager.terrainChunk.get(chunkIdentifier.getChunkID());
        }
        //If cache and/or database don't have the chunk, generate it and store it:
        else {
            final MPTerrainChunk generatedChunk = terrainGenerator.generateChunk(chunkRow, chunkCol);
            DBManager.terrainChunk.create(generatedChunk);
            MPWorld updatedWorld = DBManager.world.get(worldID);
            updatedWorld.addChunk(generatedChunk.getId());
            DBManager.world.update(updatedWorld);
            return generatedChunk;
        }
    }

    /**
     * Retrieves the terrain cells that are within the area of interest of a list of entities.
     * @param entities The list of entities.
     * @return Returns a Map containing the terrain cells.
     */
    public Map<String, MPTerrainCellProto> getTerrain(Collection<MPEntity> entities) {

        HashMap<String, MPTerrainCellProto> cells = new HashMap<>();

        HashSet<MatrixPosition> chunksNeeded = new HashSet<>();
        for (MPEntity entity : entities) {
            int minRow, maxRow, minCol, maxCol;
            minRow = (int) (entity.getPosition().getRow() - entity.getAreaOfInterest());
            maxRow = (int) (entity.getPosition().getRow() + entity.getAreaOfInterest());
            minCol = (int) (entity.getPosition().getCol() - entity.getAreaOfInterest());
            maxCol = (int) (entity.getPosition().getCol() + entity.getAreaOfInterest());

            final int INCREMENTATION_STEP = (int) Math.min(entity.getAreaOfInterest(), MPTerrainChunk.SIZE);

            for (int cellRow = minRow; cellRow <= maxRow; cellRow += INCREMENTATION_STEP) {
                for (int cellCol = minCol; cellCol <= maxCol; cellCol += INCREMENTATION_STEP) {
                    chunksNeeded.add(MPTerrainChunk.getChunkPosition(cellRow, cellCol));
                }
            }
        }

        ArrayList<MPTerrainChunk> chunks = new ArrayList<>();
        for (MatrixPosition chunkPos : chunksNeeded) {
            if (world.chunkIsInBounds(chunkPos.getRow(), chunkPos.getCol())) {
                //Request the entire chunk:
                long t = System.currentTimeMillis();
                MPTerrainChunk chunk = requestChunk(chunkPos.getRow(), chunkPos.getCol());
                chunks.add(chunk);
            }
        }

        for (MPEntity entity : entities) {
            for (MPTerrainChunk chunk : chunks) {
                //Only include cells from this chunk that are within the AoI:
                for (Map.Entry<String, MPTerrainCell> entry : chunk.getCells().entrySet()) {
                    final MatrixPosition position = entry.getValue().getPosition();
                    final double distance = position.distanceTo(entity.getPosition());
                    if (distance <= entity.getAreaOfInterest()) {
                        cells.put(position.toHash(), entry.getValue().toProto().build());
                    }
                }
            }
        }
        return cells;
    }

    /**
     * NEW!
     * Retrieves the terrain cells that are within the area of interest of a list of entities.
     * @param entities The list of entities.
     * @return Returns a Map containing the terrain cells.
     */
    public Map<String, MPTerrainCellProto> getTerrain(List<MPEntityProto> entities) {

        HashMap<String, MPTerrainCellProto> cells = new HashMap<>();

        HashSet<MatrixPosition> chunksNeeded = new HashSet<>();
        for (MPEntityProto entity : entities) {
            int minRow, maxRow, minCol, maxCol;
            minRow = (int) (entity.getPosition().getRow() - entity.getAreaOfInterest());
            maxRow = (int) (entity.getPosition().getRow() + entity.getAreaOfInterest());
            minCol = (int) (entity.getPosition().getCol() - entity.getAreaOfInterest());
            maxCol = (int) (entity.getPosition().getCol() + entity.getAreaOfInterest());

            final int INCREMENTATION_STEP = (int) Math.min(entity.getAreaOfInterest(), MPTerrainChunk.SIZE);

            for (int cellRow = minRow; cellRow <= maxRow; cellRow += INCREMENTATION_STEP) {
                for (int cellCol = minCol; cellCol <= maxCol; cellCol += INCREMENTATION_STEP) {
                    chunksNeeded.add(MPTerrainChunk.getChunkPosition(cellRow, cellCol));
                }
            }
        }

        ArrayList<MPTerrainChunk> chunks = new ArrayList<>();
        for (MatrixPosition chunkPos : chunksNeeded) {
            if (world.chunkIsInBounds(chunkPos.getRow(), chunkPos.getCol())) {
                //Request the entire chunk:
                long t = System.currentTimeMillis();
                MPTerrainChunk chunk = requestChunk(chunkPos.getRow(), chunkPos.getCol());
                chunks.add(chunk);
            }
        }

        for (MPEntityProto entity : entities) {
            for (MPTerrainChunk chunk : chunks) {
                //Only include cells from this chunk that are within the AoI:
                for (Map.Entry<String, MPTerrainCell> entry : chunk.getCells().entrySet()) {
                    final MatrixPosition position = entry.getValue().getPosition();
                    final double distance = position.distanceTo(entity.getPosition().toObject());
                    if (distance <= entity.getAreaOfInterest()) {
                        cells.put(position.toHash(), entry.getValue().toProto().build());
                    }
                }
            }
        }
        return cells;
    }

    /**
     * Retrieves the terrain cells that are within the area of interest of a specific position.
     * @param position The position.
     * @param radius The radius of the area of interest.
     * @return Returns a map of terrain cells.
     */
    public Map<String, MPTerrainCellProto> getTerrain(MatrixPosition position, float radius) {
        HashMap<String, MPTerrainCellProto> cells = new HashMap<>();

        HashSet<MatrixPosition> chunksNeeded = new HashSet<>();
        int minRow, maxRow, minCol, maxCol;
        minRow = (int) (position.getRow() - radius);
        maxRow = (int) (position.getRow() + radius);
        minCol = (int) (position.getCol() - radius);
        maxCol = (int) (position.getCol() + radius);

        final int INCREMENTATION_STEP = (int) Math.min(radius, MPTerrainChunk.SIZE);

        for (int cellRow = minRow; cellRow <= maxRow; cellRow += INCREMENTATION_STEP) {
            for (int cellCol = minCol; cellCol <= maxCol; cellCol += INCREMENTATION_STEP) {
                chunksNeeded.add(MPTerrainChunk.getChunkPosition(cellRow, cellCol));
            }
        }

        ArrayList<MPTerrainChunk> chunks = new ArrayList<>();
        for (MatrixPosition chunkPos : chunksNeeded) {
            if (world.chunkIsInBounds(chunkPos.getRow(), chunkPos.getCol())) {
                //Request the entire chunk:
                long t = System.currentTimeMillis();
                MPTerrainChunk chunk = requestChunk(chunkPos.getRow(), chunkPos.getCol());
                chunks.add(chunk);
            }
        }

        for (MPTerrainChunk chunk : chunks) {
            //Only include cells from this chunk that are within the AoI:
            for (Map.Entry<String, MPTerrainCell> entry : chunk.getCells().entrySet()) {
                final MatrixPosition cellPosition = entry.getValue().getPosition();
                final double distance = cellPosition.distanceTo(position);
                if (distance <= radius) {
                    cells.put(cellPosition.toHash(), entry.getValue().toProto().build());
                }
            }
        }
        return cells;
    }

    /**
     * Retrieves the entities that are within the area of interest of a given set of entities.
     * @param entities The entities given.
     * @return Returns a map of entities.
     */
    public Map<String, MPEntityProto> getEntities(Collection<MPEntity> entities) {
        HashMap<String, MPEntityProto> entitiesInAOI = new HashMap<>();
        for (MPEntity e : entities) {
            entitiesInAOI.put(e.getId(), e.toProto().build());
        }
        final Collection<MPEntity> allEntities = DBManager.entity.listForWorld(worldID);
        allEntities.addAll(DBManager.buildingEntity.listForWorld(worldID));
        for (MPEntity providedEntity : entities) {
            for (MPEntity entity : allEntities) {
                if (!providedEntity.getId().equals(entity.getId()) && !entitiesInAOI.containsKey(entity.getId())) {
                    if (providedEntity.getPosition().distanceTo(entity.getPosition()) <= providedEntity.getAreaOfInterest()) {
                        entitiesInAOI.put(entity.getId(), entity.toProto().build());
                    }
                }
            }
        }
        return entitiesInAOI;
    }

    /**
     * Retrieves the entities that are within a radius of a given position.
     * @param position The position given.
     * @param radius The radius.
     * @return Returns a map of entities.
     */
    public Map<String, MPEntityProto> getEntities(MatrixPosition position, float radius) {
        HashMap<String, MPEntityProto> entitiesInAOI = new HashMap<>();
        final Collection<BuildingEntity> allEntities = DBManager.buildingEntity.listForWorld(worldID);
        for (BuildingEntity entity : allEntities) {
            if (!entitiesInAOI.containsKey(entity.getId())) {
                if (position.distanceTo(entity.getPosition()) <= radius) {
                    entitiesInAOI.put(entity.getId(), entity.toProto().build());
                }
            }
        }
        return entitiesInAOI;
    }

    /**
     * Composes the partial state for a given world session and set of entities.
     * @param worldSession The world session to compose the state for.
     * @return Returns a PartialStateProto.
     */
    public MPPartialStateProto composeState(MPWorldSession worldSession) {
        //Retrieve the player's own entities:
        final Collection<MPEntity> playerEntities = DBManager.entity.listForPlayerAndWorld(worldSession.getWorldID(), worldSession.getPlayerID());
        playerEntities.addAll(DBManager.buildingEntity.listForPlayerAndWorld(worldSession.getWorldID(), worldSession.getPlayerID()));

        //Retrieve foreign entities that are within the area of interest of the player's entities:
        final HashMap<String, MPEntityProto> entitiesInAOI = new HashMap<>(getEntities(playerEntities));

        //Retrieve the terrain:
        final HashMap<String, MPTerrainCellProto> terrainInAOI = new HashMap<>(getTerrain(playerEntities));
        return MPPartialStateProto.newBuilder()
                .setWorldSession(worldSession.toProto())
                .putAllEntities(entitiesInAOI)
                .putAllCells(terrainInAOI)
                .build();
    }

    /**
     * Composes the partial state based on a given position and area of interest.
     * @param worldSession The world session to compose the state for.
     * @return Returns a PartialStateProto.
     */
    public MPPartialStateProto composeState(MPWorldSession worldSession, MatrixPosition position, float areaOfEffect) {
        //Retrieve foreign entities that are within the area of interest:
        final HashMap<String, MPEntityProto> entitiesInAOI = new HashMap<>(getEntities(position, areaOfEffect));

        //Retrieve the terrain:
        final HashMap<String, MPTerrainCellProto> terrainInAOI = new HashMap<>(getTerrain(position, areaOfEffect));
        return MPPartialStateProto.newBuilder()
                .setWorldSession(worldSession.toProto())
                .putAllEntities(entitiesInAOI)
                .putAllCells(terrainInAOI)
                .build();
    }

    /**
     * Composes a state refresh - similar to composeState(), but returns a StateUpdate.
     * @return Returns a StateUpdateProto.
     */
    private MPStateUpdateProto composeStateRefresh(MatrixPosition position, float areaOfEffect) {
        //Retrieve foreign entities that are within the area of interest:
        final HashMap<String, MPEntityProto> entitiesInAOI = new HashMap<>(getEntities(position, areaOfEffect));

        //Retrieve the terrain:
        final HashMap<String, MPTerrainCellProto> terrainInAOI = new HashMap<>(getTerrain(position, areaOfEffect));

        final StateUpdateBuilder stateUpdateBuilder = StateUpdateBuilder.create();

        for (MPTerrainCellProto terrainCell : terrainInAOI.values()) {
            stateUpdateBuilder.addUpdatedTerrain(terrainCell);
        }

        for (MPEntityProto entity : entitiesInAOI.values()) {
            stateUpdateBuilder.addUpdatedEntity(entity);
        }

        return stateUpdateBuilder.build();
    }

    /**
     * Refreshes the terrain of a particular StateUpdateBuilder using the new entities' AoI.
     * @param entities The old (existing) entities.
     * @param stateUpdateBuilder The builder, which contains the new entities.
     * @return Returns a StateUpdateBuilder.
     */
    public StateUpdateBuilder refreshTerrain(List<MPEntityProto> entities, StateUpdateBuilder stateUpdateBuilder) {
        final Map<String, MPTerrainCellProto> terrain = getTerrain(entities);
        for (MPTerrainCellProto terrainCell : terrain.values()) {
            stateUpdateBuilder.addCreatedTerrain(terrainCell);
        }
        return stateUpdateBuilder;
    }

    /**
     * Refreshes the entities of a particular StateUpdateBuilder.
     * @param stateUpdateBuilder The builder.
     * @return Returns a StateUpdateBuilder.
     */
    public StateUpdateBuilder refreshEntities(MPWorldSession worldSession, StateUpdateBuilder stateUpdateBuilder) {
        final Collection<MPEntity> playerEntities = DBManager.entity.listForPlayerAndWorld(worldSession.getWorldID(), worldSession.getPlayerID());
        final Map<String, MPEntityProto> aoiEntities = getEntities(playerEntities);
        for (MPEntityProto value : aoiEntities.values()) {
            stateUpdateBuilder.addCreatedEntity(value);
        }
        return stateUpdateBuilder;
    }

    /**
     * Refreshes an existing state's terrain ONLY, using existing entities in the stateUpdateBuilder provided.
     * @param stateUpdateBuilder An existing state update builder, containing the entities created in the last action.
     * @return Returns a StateUpdateBuilder.
     */
    public StateUpdateBuilder checkAndRefreshTerrain(StateUpdateBuilder stateUpdateBuilder) {
        //For each entity, find if the a entity is contained inside it
//        final Collection<MPEntity> entities = DBManager.entity.listForPlayerAndWorld(worldSession.getWorldID(), worldSession.getPlayerID());
        final List<MPEntityProto> entities = new ArrayList<>();

        entities.addAll(stateUpdateBuilder.getCreatedEntities().values());
        entities.addAll(stateUpdateBuilder.getUpdatedEntities().values());

        boolean contained = false;
        outterloop:
        for (MPEntityProto existingEntity : entities) {
            for (MPEntityProto createdEntity : stateUpdateBuilder.getCreatedEntities().values()) {
                double distance = existingEntity.getPosition().distanceTo(createdEntity.getPosition());
                if (existingEntity.getAreaOfInterest() > (distance + createdEntity.getAreaOfInterest())) {
                    contained = true;
                    break outterloop;
                }
            }
        }

        //If not contained, fetch the terrain
        if (!contained) {
            stateUpdateBuilder = refreshTerrain(entities, stateUpdateBuilder);
        }

        return stateUpdateBuilder;
    }

    /**
     * Composes a custom state update, optionally refreshing the terrain and/or entities.
     * Important note: Refreshing terrain/entities may impact the performance of this method significantly. Opt to refresh
     * the terrain and entities only when necessary.
     * @param stateUpdateBuilder The state update, as provided by the action made.
     * @return Returns a StateUpdateProto
     */
    public MPStateUpdateProto composeStateUpdate(MPWorldSession worldSession, StateUpdateBuilder stateUpdateBuilder,
                                                 boolean refreshTerrain, boolean refreshEntities) {
        if (refreshTerrain) {
            stateUpdateBuilder = checkAndRefreshTerrain(stateUpdateBuilder);
        }
        if (refreshEntities) {
            stateUpdateBuilder = refreshEntities(worldSession, stateUpdateBuilder);
        }
        return stateUpdateBuilder.build();
    }

    /**
     * Returns the active sessions for this world.
     * @return Returns a collection of WorldSessions.
     */
    public Collection<MPWorldSession> getAllSessions() {
        return DBManager.worldSession.listForWorld(worldID);
    }

    /**
     * Returns the subscribed sessions (those receiving state updates) for this world.
     * @return Returns the subscribed sessions of this world.
     */
    public Collection<MPWorldSession> getSubscribedSessions() {
        final List<String> subscribedSessionIDs = DBManager.world.get(worldID).getSubscribedSessionIDs();
        ArrayList<MPWorldSession> worldSessions = new ArrayList<>();
        for (String subscribedSessionID : subscribedSessionIDs) {
            final MPWorldSession worldSession = DBManager.worldSession.get(subscribedSessionID);
            worldSessions.add(worldSession);
        }
        return worldSessions;
    }

    /**
     * Subscribes a world session to a world.
     * @param worldSession The world session.
     */
    public void subscribe(MPWorldSession worldSession) {
        final MPWorld world = DBManager.world.get(worldID);
        if (!world.getSubscribedSessionIDs().contains(worldSession.getId())) {
            world.getSubscribedSessionIDs().add(worldSession.getId());
            DBManager.world.update(world);
            System.out.println("subbed -> " + world.getSubscribedSessionIDs());
        }
    }

    /**
     * Unsubscribes a world session.
     * @param worldSession The world session to unsubscribe.
     */
    public void unsubscribe(MPWorldSession worldSession) {
        final MPWorld world = DBManager.world.get(worldID);
        world.getSubscribedSessionIDs().remove(worldSession.getId());
        DBManager.world.update(world);
    }

}

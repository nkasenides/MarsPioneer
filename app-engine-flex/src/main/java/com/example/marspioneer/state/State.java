/* --------------------------------------------------------------------------------
  This file was automatically generated by the Athlos Project Editor.
  Athlos Project Editor, v1.0 BETA
-------------------------------------------------------------------------------- */

package com.example.marspioneer.state;


import com.example.marspioneer.model.*;
import com.example.marspioneer.persistence.DBManager;
import com.example.marspioneer.proto.GeoPositionProto;
import com.example.marspioneer.proto.MPPartialStateProto;
import com.example.marspioneer.proto.MPTerrainChunkProto;
import com.example.marspioneer.proto.MatrixPositionProto;
import com.raylabz.jsec.HashType;
import com.raylabz.jsec.Hashing;
import redis.clients.jedis.Jedis;

import java.util.ArrayList;
import java.util.Collection;

public class State {

    private static WorldContext currentContext;

    public static WorldContext forWorld(String worldID) {
        if (currentContext == null || !currentContext.getWorldID().equals(worldID)) {
            currentContext = new WorldContext(worldID);
        }
        return currentContext;
    }

    /**
     * Identifies a cell/chunk/position using its hashed value.
     * @param matrixPosition The MatrixPosition.
     * @return Returns a String hash.
     */
    public static String identify(MatrixPosition matrixPosition) {
        return Hashing.hash(HashType.MD5, matrixPosition.getRow() + "," + matrixPosition.getCol());
    }

    /**
     * Identifies a cell/chunk/position using its hashed value.
     * @param matrixPositionProto The MatrixPosition.
     * @return Returns a String hash.
     */
    public static String identify(MatrixPositionProto matrixPositionProto) {
        return Hashing.hash(HashType.MD5, matrixPositionProto.getRow() + "," + matrixPositionProto.getCol());
    }

    /**
     * Identifies a cell/chunk/position using its hashed value.
     * @param geoPosition The GeoPosition.
     * @return Returns a String hash.
     */
    public static String identify(GeoPosition geoPosition) {
        return identify(geoPosition.toMatrixPosition());
    }

    /**
     * Identifies a cell/chunk/position using its hashed value.
     * @param geoPositionProto The GeoPosition.
     * @return Returns a String hash.
     */
    public static String identify(GeoPositionProto geoPositionProto) {
        return identify(geoPositionProto.toMatrixPosition());
    }

    /**
     * Filters the sessions that should be updated based on game-specific criteria.
     * TODO - Change this function based on your game-specific needs for custom filtering of state updates.
     * @param areaOfEffect The area of effect of the action.
     * @param actionPosition The action position.
     * @param worldID The ID of the world.
     * @return Returns a collection of world sessions.
     */
    public static Collection<MPWorldSession> filterUpdateSessions(String worldID, MatrixPosition actionPosition, float areaOfEffect) {
        ArrayList<MPWorldSession> allSessions = new ArrayList<>(State.forWorld(worldID).getSubscribedSessions());
        ArrayList<MPWorldSession> filteredSessions = new ArrayList<>();
        for (MPWorldSession worldSession : allSessions) {

            //Check entity area of interest vs action area of effect:
            boolean hasEntitiesInAOI = false;
            final Collection<MPEntity> playerEntities = DBManager.entity.listForPlayerAndWorld(worldSession.getWorldID(), worldSession.getPlayerID());
            playerEntities.addAll(DBManager.buildingEntity.listForPlayerAndWorld(worldSession.getWorldID(), worldSession.getPlayerID()));

            for (MPEntity entity : playerEntities) {
                if (entity.getAreaOfInterest() > 0) {
                    boolean intersects = Math.hypot(actionPosition.getCol() - entity.getPosition().getCol(), actionPosition.getRow() - entity.getPosition().getRow()) <= (areaOfEffect + entity.getAreaOfInterest());
                    if (intersects) {
                        hasEntitiesInAOI = true;
                        break;
                    }
                }
            }

            //Check camera positioning:
            boolean cameraIsInRange = worldSession.getCameraPosition().distanceTo(actionPosition) <= areaOfEffect;

            if (hasEntitiesInAOI && cameraIsInRange) {
                filteredSessions.add(worldSession);
            }

        }
        return filteredSessions;
    }

}

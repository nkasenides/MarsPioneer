/* --------------------------------------------------------------------------------
  This file was automatically generated by the Athlos Project Editor.
  Athlos Project Editor, v1.0 BETA
-------------------------------------------------------------------------------- */

package com.example.marspioneer.websocket;

import com.example.marspioneer.proto.*;
import com.example.marspioneer.model.*;
import com.example.marspioneer.persistence.DBManager;
import com.example.marspioneer.state.State;
import org.eclipse.jetty.websocket.api.Session;
import org.eclipse.jetty.websocket.api.annotations.*;

import javax.servlet.http.HttpServletRequest;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Future;

@WebSocket(maxIdleTime = -1)
public class UpdateStateWebSocket {

    private Session session;
    private String worldSessionID;
    private final HttpServletRequest request;

    private static final ConcurrentHashMap<String, Session> CONNECTED_SESSIONS = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<String, UpdateStateWebSocket> SOCKET_INSTANCES = new ConcurrentHashMap<>();

    public Session getSession() {
        return session;
    }

    public HttpServletRequest getRequest() {
        return request;
    }

    public String getWorldSessionID() {
        return worldSessionID;
    }

    public UpdateStateWebSocket(HttpServletRequest request) {
        this.request = request;
    }

    @OnWebSocketConnect
    public void onConnect(Session session) {
        this.session = session;
        session.setIdleTimeout(-1);
    }

    @OnWebSocketMessage
    public void onMessage(byte[] bytes, int offset, int length) throws IOException {
        UpdateStateRequest request = UpdateStateRequest.parseFrom(bytes);
        handleMessage(request);
    }

    /**
     * Handles a request.
     * @param request The incoming request.
     */
    public void handleMessage(UpdateStateRequest request) throws IOException {
        this.worldSessionID = request.getWorldSessionID();
        CONNECTED_SESSIONS.put(request.getWorldSessionID(), session);
        SOCKET_INSTANCES.put(request.getWorldSessionID(), this);
    }

    /**
     * Sends a state update to a particular world session.
     * @param worldSession The world session initiating the state update.
     * @param response The response to send.
     * @throws IOException thrown when the message cannot be sent via the socket.
     */
    public static void sendUpdate(final MPWorldSession worldSession, UpdateStateResponse response) throws IOException {
        final Session socketSession = CONNECTED_SESSIONS.get(worldSession.getId());
        final UpdateStateWebSocket socket = SOCKET_INSTANCES.get(worldSession.getId());
        if (socketSession != null && socket != null && socketSession.isOpen()) {
            socket.send(socketSession, response);
        }
    }

    /**
     * Sends a state update to a set of world sessions. Each session receives the own update.
     * @param responses A map of world sessions and their corresponding responses.
     * @throws IOException thrown when the message cannot be sent via the socket.
     */
    public static void sendUpdate(HashMap<MPWorldSession, UpdateStateResponse> responses) throws IOException {
        for (Map.Entry<MPWorldSession, UpdateStateResponse> entry : responses.entrySet()) {
            sendUpdate(entry.getKey(), entry.getValue());
        }
    }

    /**
     * Broadcasts the same state update to all subscribed sessions.
     * @param worldID The world ID of the world the broadcasted update belongs to.
     * @param response The response to send.
     * @throws IOException thrown when the message cannot be sent via the socket.
     */
    public static void broadcastUpdate(final String worldID, UpdateStateResponse response) throws IOException {
        final Collection<MPWorldSession> allSessions = State.forWorld(worldID).getSubscribedSessions();
        for (MPWorldSession session : allSessions) {
            final Session socketSession = CONNECTED_SESSIONS.get(session.getId());
            final UpdateStateWebSocket socket = SOCKET_INSTANCES.get(session.getId());
            socket.send(socketSession, response);
        }
    }

    /**
     * Multicasts the same state update to the provided sessions.
     * @param worldID The ID of the world the update belongs to.
     * @param response The response to send.
     * @param worldSessions The sessions to receive the state updates.
     * @throws IOException thrown when the message cannot be sent via the socket.
     */
    public static void multicastUpdate(final String worldID, UpdateStateResponse  response, List<MPWorldSession> worldSessions) throws IOException {
        final Collection<MPWorldSession> allSessions = State.forWorld(worldID).getSubscribedSessions();
        for (MPWorldSession session : allSessions) {
            boolean contains = false;
            for (MPWorldSession worldSession : worldSessions) {
                if (worldSession.getId().equals(session.getId())) {
                    contains = true;
                    break;
                }
            }
            if (contains) {
                final Session socketSession = CONNECTED_SESSIONS.get(session.getId());
                final UpdateStateWebSocket socket = SOCKET_INSTANCES.get(session.getId());
                socket.send(socketSession, response);
            }
        }
    }

    @OnWebSocketClose
    public void onClose(int statusCode, String reason) {
        CONNECTED_SESSIONS.remove(worldSessionID);
        SOCKET_INSTANCES.remove(worldSessionID);
    }

    @OnWebSocketError
    public void onError(Throwable cause) {
        System.err.println("WebSocket error -> " + cause);
        cause.printStackTrace();
        CONNECTED_SESSIONS.remove(worldSessionID);
        SOCKET_INSTANCES.remove(worldSessionID);
    }

    /**
     * Sends a message to the requester and waits for the message to be sent.
     * @param response The response to send.
     * @throws IOException when data cannot be converted into bytes.
     */
    private void sendAndWait(UpdateStateResponse response) throws IOException {
        session.getRemote().sendBytes(ByteBuffer.wrap(response.toByteArray()));
    }

    /**
     * Sends a message to the requester and continues without waiting.
     * @param response The response to send.
     * @throws IOException when data cannot be converted into bytes.
     */
    private Future<Void> send(UpdateStateResponse response) throws IOException {
        return session.getRemote().sendBytesByFuture(ByteBuffer.wrap(response.toByteArray()));
    }

    /**
     * Sends a message to an arbitrary session and continues without waiting.
     * @param response The response to send.
     * @throws IOException when data cannot be converted into bytes.
     */
    private void send(Session session, UpdateStateResponse response) throws IOException {
        session.getRemote().sendBytes(ByteBuffer.wrap(response.toByteArray()));
    }

    /**
     * Sends a message to an arbitrary session and waits for the message to be sent.
     * @param response The response to send.
     * @throws IOException when data cannot be converted into bytes.
     */
    private Future<Void> sendAndWait(Session session, UpdateStateResponse response) throws IOException {
        return session.getRemote().sendBytesByFuture(ByteBuffer.wrap(response.toByteArray()));
    }

    /**
     * Sends a message to a collection of sessions and continues without waiting.
     * @param response The response to send.
     * @throws IOException when data cannot be converted into bytes.
     */
    private void send(Collection<Session> sessions, UpdateStateResponse response) throws IOException {
        for (Session session : sessions) {
            session.getRemote().sendBytes(ByteBuffer.wrap(response.toByteArray()));
        }
    }

    /**
     * Sends a message to a collection of sessions and waits for the message to be sent.
     * @param response The response to send.
     * @throws IOException when data cannot be converted into bytes.
     */
    private void sendAndWait(Collection<Session> sessions, UpdateStateResponse response) throws IOException {
        for (Session session : sessions) {
            session.getRemote().sendBytesByFuture(ByteBuffer.wrap(response.toByteArray()));
        }
    }

}



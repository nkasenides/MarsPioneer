/* --------------------------------------------------------------------------------
  This file was automatically generated by the Athlos Project Editor.
  Athlos Project Editor, v1.0 BETA
-------------------------------------------------------------------------------- */

package com.example.marspioneer.websocket;

import com.example.marspioneer.proto.*;
import com.example.marspioneer.model.*;
import com.example.marspioneer.persistence.DBManager;
import com.example.marspioneer.state.State;import com.google.protobuf.InvalidProtocolBufferException;
import org.eclipse.jetty.websocket.api.Session;
import org.eclipse.jetty.websocket.api.annotations.*;
import redis.clients.jedis.Jedis;

import javax.servlet.http.HttpServletRequest;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Future;

@WebSocket(maxIdleTime = -1)
public class UpdateStateWebSocket {

    private Session session;
    private String worldSessionID;
    private final HttpServletRequest request;

    private static final ConcurrentHashMap<String, Session> CONNECTED_SESSIONS = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<String, UpdateStateWebSocket> SOCKET_INSTANCES = new ConcurrentHashMap<>();

    public Session getSession() {
        return session;
    }

    public HttpServletRequest getRequest() {
        return request;
    }

    public String getWorldSessionID() {
        return worldSessionID;
    }

    public UpdateStateWebSocket(HttpServletRequest request) {
        this.request = request;
    }

    @OnWebSocketConnect
    public void onConnect(Session session) {
        this.session = session;
        session.setIdleTimeout(-1);
    }

    @OnWebSocketMessage
    public void onMessage(byte[] bytes, int offset, int length) throws IOException {
        UpdateStateRequest request = UpdateStateRequest.parseFrom(bytes);
        handleMessage(request);
    }

    /**
     * Handles a request.
     * @param request The incoming request.
     */
    public void handleMessage(UpdateStateRequest request) throws IOException {
        this.worldSessionID = request.getWorldSessionID();
        CONNECTED_SESSIONS.put(request.getWorldSessionID(), session);
        SOCKET_INSTANCES.put(request.getWorldSessionID(), this);
    }

    /**
     * Runs a state update across sessions that should be receiving this update, based on the filtering function defined in State.filterUpdateSessions().
     * @param worldSession The world session initiating the state update.
     * @param actionPosition The position of the action that initiated the state update.
     * @param areaOfEffect The area of effect (AoE) of the action that initiated the state update.
     * @throws IOException thrown when the message cannot be sent via the socket.
     */
    public static void filteredUpdate(final MPWorldSession worldSession, final MatrixPosition actionPosition, final float areaOfEffect, Jedis jedis, MPPlayer player) throws IOException {
        final Collection<MPWorldSession> allSessions = DBManager.worldSession.listForWorld(worldSession.getWorldID());
        final Collection<MPWorldSession> sessionsToUpdate = State.filterUpdateSessions(allSessions, actionPosition, areaOfEffect);
        for (MPWorldSession session : sessionsToUpdate) {
            final Session socketSession = CONNECTED_SESSIONS.get(session.getId());
            final UpdateStateWebSocket socket = SOCKET_INSTANCES.get(session.getId());
            final UpdateStateResponse response = UpdateStateResponse.newBuilder()
                    .setStatus(UpdateStateResponse.Status.OK)
                    .setMessage("OK")
                    .setResourceSet(
                            ResourceSetProto.newBuilder()
                            .setFood(player.getFood())
                            .setMetal(player.getMetal())
                            .setSand(player.getSand())
                            .setWater(player.getWater())
                            .build()
                    )
                    .setPartialState(State.forWorld(worldSession.getWorldID(), jedis).composeStateUpdate(session))
                    .build();
            socket.send(socketSession, response);
        }
    }

    /**
     * Broadcasts a state update to all connected sessions.
     * @param response The response to send to the connected sessions.
     * @throws IOException thrown when the message cannot be sent via the socket.
     */
    public static void broadcastUpdate(UpdateStateResponse response) throws IOException {
        for (Map.Entry<String, Session> entry : CONNECTED_SESSIONS.entrySet()) {
            SOCKET_INSTANCES.get(entry.getKey()).send(entry.getValue(), response);
        }
    }
    /**
     * Multicasts a state update to the provided sessions.
     * @param worldSessionIDs The IDs of the sessions to receive the state updates.
     * @param response The response to send to the connected sessions.
     * @throws IOException thrown when the message cannot be sent via the socket.
     */
    public static void multicastUpdate(Collection<String> worldSessionIDs, UpdateStateResponse response) throws IOException {
        for (String id : worldSessionIDs) {
            final Session socketSession = CONNECTED_SESSIONS.get(id);
            SOCKET_INSTANCES.get(id).send(socketSession, response);
        }
    }
    @OnWebSocketClose
    public void onClose(int statusCode, String reason) {
        CONNECTED_SESSIONS.remove(worldSessionID);
        SOCKET_INSTANCES.remove(worldSessionID);
    }

    @OnWebSocketError
    public void onError(Throwable cause) {
        //TODO - Handle the error
        System.err.println("WebSocket error -> " + cause);
        cause.printStackTrace();
    }

    /**
     * Sends a message to the requester and waits for the message to be sent.
     * @param response The response to send.
     * @throws IOException when data cannot be converted into bytes.
     */
    private void sendAndWait(UpdateStateResponse response) throws IOException {
        session.getRemote().sendBytes(ByteBuffer.wrap(response.toByteArray()));
    }

    /**
     * Sends a message to the requester and continues without waiting.
     * @param response The response to send.
     * @throws IOException when data cannot be converted into bytes.
     */
    private Future<Void> send(UpdateStateResponse response) throws IOException {
        return session.getRemote().sendBytesByFuture(ByteBuffer.wrap(response.toByteArray()));
    }

    /**
     * Sends a message to an arbitrary session and continues without waiting.
     * @param response The response to send.
     * @throws IOException when data cannot be converted into bytes.
     */
    private void send(Session session, UpdateStateResponse response) throws IOException {
        session.getRemote().sendBytes(ByteBuffer.wrap(response.toByteArray()));
    }

    /**
     * Sends a message to an arbitrary session and waits for the message to be sent.
     * @param response The response to send.
     * @throws IOException when data cannot be converted into bytes.
     */
    private Future<Void> sendAndWait(Session session, UpdateStateResponse response) throws IOException {
        return session.getRemote().sendBytesByFuture(ByteBuffer.wrap(response.toByteArray()));
    }

    /**
     * Sends a message to a collection of sessions and continues without waiting.
     * @param response The response to send.
     * @throws IOException when data cannot be converted into bytes.
     */
    private void send(Collection<Session> sessions, UpdateStateResponse response) throws IOException {
        for (Session session : sessions) {
            session.getRemote().sendBytes(ByteBuffer.wrap(response.toByteArray()));
        }
    }

    /**
     * Sends a message to a collection of sessions and waits for the message to be sent.
     * @param response The response to send.
     * @throws IOException when data cannot be converted into bytes.
     */
    private void sendAndWait(Collection<Session> sessions, UpdateStateResponse response) throws IOException {
        for (Session session : sessions) {
            session.getRemote().sendBytesByFuture(ByteBuffer.wrap(response.toByteArray()));
        }
    }

}


